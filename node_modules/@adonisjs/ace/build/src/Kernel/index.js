"use strict";
/*
 * @adonisjs/ace
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Kernel = void 0;
const Hooks_1 = require("../Hooks");
const Parser_1 = require("../Parser");
const HelpCommand_1 = require("../HelpCommand");
const Exceptions_1 = require("../Exceptions");
const help_1 = require("../utils/help");
const validateCommand_1 = require("../utils/validateCommand");
/**
 * Ace kernel class is used to register, find and invoke commands by
 * parsing `process.argv.splice(2)` value.
 */
class Kernel {
    constructor(application) {
        this.application = application;
        /**
         * List of registered commands
         */
        this.commands = {};
        /**
         * List of registered flags
         */
        this.flags = {};
        /**
         * Reference to hooks class to execute lifecycle
         * hooks
         */
        this.hooks = new Hooks_1.Hooks();
        /**
         * The default command that will be invoked when no command is
         * defined
         */
        this.defaultCommand = HelpCommand_1.HelpCommand;
    }
    /**
     * Executing global flag handlers. The global flag handlers are
     * not async as of now, but later we can look into making them
     * async.
     */
    executeGlobalFlagsHandlers(options, command) {
        const globalFlags = Object.keys(this.flags);
        globalFlags.forEach((name) => {
            const value = options[name];
            /**
             * Flag was not specified
             */
            if (value === undefined) {
                return;
            }
            /**
             * Flag was not specified, but `getops` will return empty array or
             * empty string, when we coerce flag to be a string or array
             */
            if ((typeof value === 'string' || Array.isArray(value)) && !value.length) {
                return;
            }
            /**
             * Calling the handler
             */
            this.flags[name].handler(options[name], options, command);
        });
    }
    /**
     * Returns an array of all registered commands
     */
    getAllCommands() {
        let commands = Object.keys(this.commands).map((name) => this.commands[name]);
        /**
         * Concat manifest commands when they exists
         */
        if (this.manifestLoader && this.manifestLoader.booted) {
            commands = commands.concat(this.manifestLoader.getCommands());
        }
        return commands;
    }
    before(action, callback) {
        this.hooks.add('before', action, callback);
        return this;
    }
    after(action, callback) {
        this.hooks.add('after', action, callback);
        return this;
    }
    /**
     * Register an array of command constructors
     */
    register(commands) {
        commands.forEach((command) => {
            command.boot();
            validateCommand_1.validateCommand(command);
            this.commands[command.commandName] = command;
        });
        return this;
    }
    /**
     * Returns an array of command names suggestions for a given name.
     */
    getSuggestions(name, distance = 3) {
        const leven = require('leven');
        return this.getAllCommands().filter(({ commandName }) => {
            return leven(name, commandName) <= distance;
        });
    }
    /**
     * Register a global flag. It can be defined in combination with
     * any command.
     */
    flag(name, handler, options) {
        this.flags[name] = Object.assign({
            name,
            propertyName: name,
            handler,
            type: 'boolean',
        }, options);
        return this;
    }
    /**
     * Finds the command from the command line argv array. If command for
     * the given name doesn't exists, then it will return `null`.
     */
    async find(argv) {
        /**
         * ----------------------------------------------------------------------------
         * Even though in `Unix` the command name may appear in between or at last, with
         * ace we always want the command name to be the first argument. However, the
         * arguments to the command itself can appear in any sequence. For example:
         *
         * Works
         *    - node ace make:controller foo
         *    - node ace make:controller --http foo
         *
         * Doesn't work
         *    - node ace foo make:controller
         * ----------------------------------------------------------------------------
         */
        const [commandName] = argv;
        /**
         * Manifest commands gets preference over manually registered commands.
         */
        if (this.manifestLoader && this.manifestLoader.hasCommand(commandName)) {
            const commandNode = this.manifestLoader.getCommand(commandName);
            await this.hooks.excute('before', 'find', commandNode.command);
            const command = this.manifestLoader.loadCommand(commandName);
            await this.hooks.excute('after', 'find', command);
            return command;
        }
        /**
         * Try to find command inside manually registered command or fallback
         * to null
         */
        const command = this.commands[commandName] || null;
        /**
         * Executing before and after together to be compatible
         * with the manifest find before and after hooks
         */
        await this.hooks.excute('before', 'find', command);
        await this.hooks.excute('after', 'find', command);
        return command;
    }
    /**
     * Run a given command by parsing the command line arguments
     */
    async runCommand(commandInstance, argv) {
        /**
         * The first value in the `argv` array is the command name. Now since
         * we know the command already, we remove the first value.
         */
        argv = argv.splice(1);
        const parser = new Parser_1.Parser(this.flags);
        const command = commandInstance.constructor;
        /**
         * Parse argv and execute the `handle` method.
         */
        const parsedOptions = parser.parse(argv, command);
        this.executeGlobalFlagsHandlers(parsedOptions, command);
        await this.hooks.excute('before', 'run', commandInstance);
        /**
         * We validate the command arguments after the global flags have been
         * executed. It is required, since flags may have nothing to do
         * with the validaty of command itself
         */
        command.args.forEach((arg, index) => {
            parser.validateArg(arg, index, parsedOptions, command);
        });
        /**
         * Creating a new command instance and setting
         * parsed options on it.
         */
        commandInstance.parsed = parsedOptions;
        /**
         * Setup command instance argument and flag
         * properties.
         */
        for (let i = 0; i < command.args.length; i++) {
            const arg = command.args[i];
            if (arg.type === 'spread') {
                commandInstance[arg.propertyName] = parsedOptions._.slice(i);
                break;
            }
            else {
                commandInstance[arg.propertyName] = parsedOptions._[i];
            }
        }
        /**
         * Set flag value on the command instance
         */
        for (let flag of command.flags) {
            const flagValue = parsedOptions[flag.name];
            if (flag.type === 'boolean') {
                commandInstance[flag.propertyName] = flagValue;
            }
            else if (!flagValue && typeof flag.defaultValue === 'function') {
                commandInstance[flag.propertyName] = await flag.defaultValue(commandInstance);
            }
            else if (flagValue || commandInstance[flag.propertyName] === undefined) {
                commandInstance[flag.propertyName] = flagValue;
            }
        }
        /**
         * Command response/error
         */
        let commandResponse;
        let commandError;
        /**
         * Wrap command inside try/catch so that we always run
         * the after run hook
         */
        try {
            commandResponse = await commandInstance.exec();
        }
        catch (error) {
            commandError = error;
        }
        await this.hooks.excute('after', 'run', commandInstance);
        /**
         * Re-throw exception after running the after run hook
         */
        if (commandError) {
            throw commandError;
        }
        return commandResponse;
    }
    /**
     * Running default command
     */
    async runDefaultCommand() {
        this.defaultCommand.boot();
        validateCommand_1.validateCommand(this.defaultCommand);
        const commandInstance = this.application.container.make(this.defaultCommand, [
            this.application,
            this,
        ]);
        return this.runCommand(commandInstance, []);
    }
    /**
     * Preload the manifest file. Re-running this method twice will
     * result in a noop
     */
    async preloadManifest() {
        /**
         * Load manifest commands when instance of manifest exists. From here the
         * kernel will give preference to the `manifest` file vs manually
         * registered commands.
         */
        if (this.manifestLoader) {
            await this.manifestLoader.boot();
        }
    }
    /**
     * Makes instance of a given command by processing command line arguments
     * and setting them on the command instance
     */
    async handle(argv) {
        await this.preloadManifest();
        /**
         * Execute the default command when no command is mentioned
         */
        if (!argv.length) {
            return this.runDefaultCommand();
        }
        const hasMentionedCommand = !argv[0].startsWith('-');
        /**
         * Parse flags when no command is defined
         */
        if (!hasMentionedCommand) {
            const parsedOptions = new Parser_1.Parser(this.flags).parse(argv);
            this.executeGlobalFlagsHandlers(parsedOptions);
            return;
        }
        /**
         * Execute command
         */
        return this.exec(argv[0], argv.slice(1, argv.length));
    }
    /**
     * Execute a given command. The `args` must be an array of arguments including
     * flags to be parsed and passed to the command. For exmaple:
     *
     * ```js
     * kernel.exec('make:controller', ['User', '--resource=true'])
     * ```
     */
    async exec(commandName, args) {
        let command = await this.find([commandName]);
        if (!command) {
            throw Exceptions_1.InvalidCommandException.invoke(commandName, this.getSuggestions(commandName));
        }
        const commandInstance = this.application.container.make(command, [this.application, this]);
        return this.runCommand(commandInstance, [commandName].concat(args));
    }
    /**
     * Use manifest instance to lazy load commands
     */
    useManifest(manifestLoader) {
        this.manifestLoader = manifestLoader;
        return this;
    }
    /**
     * Print the help screen for a given command or all commands/flags
     */
    printHelp(command) {
        if (command) {
            help_1.printHelpFor(command);
        }
        else {
            const flags = Object.keys(this.flags).map((name) => this.flags[name]);
            help_1.printHelp(this.getAllCommands(), flags);
        }
    }
}
exports.Kernel = Kernel;
