import { Token } from 'edge-lexer';
import { Stack } from '../Stack';
import { stringify } from './stringify';
import { EdgeBuffer } from '../EdgeBuffer';
import { generateAST } from './generateAst';
import { transformAst } from './transformAst';
import { makeCtxCallable } from './makeCtxCallable';
import { ParserTagDefinitionContract } from '../Contracts';
import { makeStatePropertyAccessor } from './makeStatePropertyAccessor';
import { collectObjectExpressionProperties } from './collectObjectExpressionProperties';
/**
 * Edge parser converts template strings to an invokable function. This module
 * uses [edge-lexer](https://github.com/edge-js/lexer) to generate a list
 * of tokens and process them against [acorn](https://npm.im/acorn).
 *
 * Edge has concepts of Tags, which are not implemented by this module and must
 * be provided by the consumer.
 *
 * ```js
 * // Tags are optional
 * const tags = {}
 *
 * // File name is required for better error reporting
 * const options = { filename: 'welcome.edge' }
 *
 * const parser = new Parser(tags, options)
 * const template = require('fs').readFileSync('welcome.edge', 'utf-8')
 *
 * const tokens = parser.parse(template)
 * console.log(fn)
 * ```
 */
export declare class Parser {
    tags: {
        [key: string]: ParserTagDefinitionContract;
    };
    asyncMode: boolean;
    stack: Stack;
    constructor(tags: {
        [key: string]: ParserTagDefinitionContract;
    }, asyncMode?: boolean, stack?: Stack);
    /**
     * Parser utilities work with the AST
     */
    utils: {
        generateAST: typeof generateAST;
        transformAst: typeof transformAst;
        stringify: typeof stringify;
        makeCtxCallable: typeof makeCtxCallable;
        makeStatePropertyAccessor: typeof makeStatePropertyAccessor;
        collectObjectExpressionProperties: typeof collectObjectExpressionProperties;
        getExpressionLoc(expression: any): {
            line: number;
            col: number;
        };
    };
    /**
     * Process escaped tag token by writing it as it is. However, the children
     * inside a tag are still processed.
     */
    private processEscapedTagToken;
    /**
     * Process escaped tag token by writing it as it is. However, the children
     * inside a tag are still processed.
     */
    private processEscapedMustache;
    /**
     * Process mustache token
     */
    private processMustache;
    /**
     * Convert template to tokens
     */
    tokenize(template: string, filename: string, onLine?: (line: string) => string): Token[];
    /**
     * Process a lexer token. The output gets written to the buffer
     */
    processToken(token: Token, buffer: EdgeBuffer): void;
}
