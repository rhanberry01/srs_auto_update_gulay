import { ApplicationContract } from '@ioc:Adonis/Core/Application';
import { ManifestLoader } from '../Manifest/Loader';
import { CommandFlag, KernelContract, CommandContract, RunHookCallback, FindHookCallback, GlobalFlagHandler, SerializedCommand, CommandConstructorContract } from '../Contracts';
/**
 * Ace kernel class is used to register, find and invoke commands by
 * parsing `process.argv.splice(2)` value.
 */
export declare class Kernel implements KernelContract {
    application: ApplicationContract;
    /**
     * List of registered commands
     */
    commands: {
        [name: string]: CommandConstructorContract;
    };
    /**
     * List of registered flags
     */
    flags: {
        [name: string]: CommandFlag<any> & {
            handler: GlobalFlagHandler;
        };
    };
    /**
     * Reference to hooks class to execute lifecycle
     * hooks
     */
    private hooks;
    /**
     * Reference to the manifest loader. If defined, we will give preference
     * to the manifest files.
     */
    private manifestLoader;
    /**
     * The default command that will be invoked when no command is
     * defined
     */
    defaultCommand: CommandConstructorContract;
    constructor(application: ApplicationContract);
    /**
     * Executing global flag handlers. The global flag handlers are
     * not async as of now, but later we can look into making them
     * async.
     */
    private executeGlobalFlagsHandlers;
    /**
     * Returns an array of all registered commands
     */
    private getAllCommands;
    /**
     * Register a before hook
     */
    before(action: 'run', callback: RunHookCallback): this;
    before(action: 'find', callback: FindHookCallback): this;
    /**
     * Register an after hook
     */
    after(action: 'run', callback: RunHookCallback): this;
    after(action: 'find', callback: FindHookCallback): this;
    /**
     * Register an array of command constructors
     */
    register(commands: CommandConstructorContract[]): this;
    /**
     * Returns an array of command names suggestions for a given name.
     */
    getSuggestions(name: string, distance?: number): SerializedCommand[];
    /**
     * Register a global flag. It can be defined in combination with
     * any command.
     */
    flag(name: string, handler: GlobalFlagHandler, options: Partial<Exclude<CommandFlag<any>, 'name' | 'propertyName'>>): this;
    /**
     * Finds the command from the command line argv array. If command for
     * the given name doesn't exists, then it will return `null`.
     */
    find(argv: string[]): Promise<CommandConstructorContract | null>;
    /**
     * Run a given command by parsing the command line arguments
     */
    runCommand(commandInstance: CommandContract, argv: string[]): Promise<any>;
    /**
     * Running default command
     */
    runDefaultCommand(): Promise<any>;
    /**
     * Preload the manifest file. Re-running this method twice will
     * result in a noop
     */
    preloadManifest(): Promise<void>;
    /**
     * Makes instance of a given command by processing command line arguments
     * and setting them on the command instance
     */
    handle(argv: string[]): Promise<any>;
    /**
     * Execute a given command. The `args` must be an array of arguments including
     * flags to be parsed and passed to the command. For exmaple:
     *
     * ```js
     * kernel.exec('make:controller', ['User', '--resource=true'])
     * ```
     */
    exec(commandName: string, args: string[]): Promise<any>;
    /**
     * Use manifest instance to lazy load commands
     */
    useManifest(manifestLoader: ManifestLoader): this;
    /**
     * Print the help screen for a given command or all commands/flags
     */
    printHelp(command?: CommandConstructorContract): void;
}
