"use strict";
/*
 * edge-parser
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const os_1 = require("os");
const edge_lexer_1 = require("edge-lexer");
const Stack_1 = require("../Stack");
const stringify_1 = require("./stringify");
const generateAst_1 = require("./generateAst");
const transformAst_1 = require("./transformAst");
const makeCtxCallable_1 = require("./makeCtxCallable");
const makeStatePropertyAccessor_1 = require("./makeStatePropertyAccessor");
const collectObjectExpressionProperties_1 = require("./collectObjectExpressionProperties");
/**
 * Edge parser converts template strings to an invokable function. This module
 * uses [edge-lexer](https://github.com/edge-js/lexer) to generate a list
 * of tokens and process them against [acorn](https://npm.im/acorn).
 *
 * Edge has concepts of Tags, which are not implemented by this module and must
 * be provided by the consumer.
 *
 * ```js
 * // Tags are optional
 * const tags = {}
 *
 * // File name is required for better error reporting
 * const options = { filename: 'welcome.edge' }
 *
 * const parser = new Parser(tags, options)
 * const template = require('fs').readFileSync('welcome.edge', 'utf-8')
 *
 * const tokens = parser.parse(template)
 * console.log(fn)
 * ```
 */
class Parser {
    constructor(tags, asyncMode = false, stack = new Stack_1.Stack()) {
        this.tags = tags;
        this.asyncMode = asyncMode;
        this.stack = stack;
        /**
         * Parser utilities work with the AST
         */
        this.utils = {
            generateAST: generateAst_1.generateAST,
            transformAst: transformAst_1.transformAst,
            stringify: stringify_1.stringify,
            makeCtxCallable: makeCtxCallable_1.makeCtxCallable,
            makeStatePropertyAccessor: makeStatePropertyAccessor_1.makeStatePropertyAccessor,
            collectObjectExpressionProperties: collectObjectExpressionProperties_1.collectObjectExpressionProperties,
            getExpressionLoc(expression) {
                var _a;
                const loc = expression.loc || ((_a = expression.property) === null || _a === void 0 ? void 0 : _a.loc);
                return {
                    line: loc.start.line,
                    col: loc.start.column,
                };
            },
        };
    }
    /**
     * Process escaped tag token by writing it as it is. However, the children
     * inside a tag are still processed.
     */
    processEscapedTagToken(token, buffer) {
        /**
         * Since `jsArg` can span over multiple lines, we split it into multiple lines
         * and write one line at a time to maintain the original shape.
         */
        const lines = `@${token.properties.name}(${token.properties.jsArg})`.split('\n');
        lines.forEach((line) => buffer.outputRaw(line));
        /**
         * Process all inner children of the tag
         */
        token.children.forEach((child) => this.processToken(child, buffer));
        /**
         * Close the tag
         */
        buffer.outputRaw(`@end${token.properties.name}`);
    }
    /**
     * Process escaped tag token by writing it as it is. However, the children
     * inside a tag are still processed.
     */
    processEscapedMustache(token, buffer) {
        const lines = token.type === edge_lexer_1.MustacheTypes.EMUSTACHE
            ? `{{${token.properties.jsArg}}}`.split('\n')
            : `{{{${token.properties.jsArg}}}}`.split('\n');
        lines.forEach((line) => buffer.outputRaw(line));
    }
    /**
     * Process mustache token
     */
    processMustache({ properties, loc, filename, type }, buffer) {
        const node = transformAst_1.transformAst(generateAst_1.generateAST(properties.jsArg, loc, filename), filename, this);
        /**
         * Wrap mustache output to an escape call for preventing XSS attacks
         */
        const expression = type === edge_lexer_1.MustacheTypes.MUSTACHE ? makeCtxCallable_1.makeCtxCallable('escape', [node]) : node;
        /**
         * Template literal, so there is no need to wrap it inside another
         * template string
         */
        if (node.type === 'TemplateLiteral') {
            buffer.outputExpression(stringify_1.stringify(expression), filename, loc.start.line, false);
        }
        else if (node.type === 'FunctionDeclaration') {
            buffer.outputExpression(stringify_1.stringify(node), filename, loc.start.line, false);
        }
        else {
            buffer.outputExpression(stringify_1.stringify(expression), filename, loc.start.line, true);
        }
    }
    /**
     * Convert template to tokens
     */
    tokenize(template, filename, onLine) {
        const tokenizer = new edge_lexer_1.Tokenizer(template, this.tags, { filename: filename, onLine });
        tokenizer.parse();
        return tokenizer.tokens;
    }
    /**
     * Process a lexer token. The output gets written to the buffer
     */
    processToken(token, buffer) {
        switch (token.type) {
            case 'raw':
                buffer.outputRaw(token.value);
                break;
            case 'newline':
                buffer.outputRaw(os_1.EOL === '\n' ? '\n' : '\r\n');
                break;
            case edge_lexer_1.TagTypes.TAG:
                this.tags[token.properties.name].compile(this, buffer, token);
                break;
            case edge_lexer_1.TagTypes.ETAG:
                this.processEscapedTagToken(token, buffer);
                break;
            case edge_lexer_1.MustacheTypes.EMUSTACHE:
            case edge_lexer_1.MustacheTypes.ESMUSTACHE:
                this.processEscapedMustache(token, buffer);
                break;
            case edge_lexer_1.MustacheTypes.SMUSTACHE:
            case edge_lexer_1.MustacheTypes.MUSTACHE:
                this.processMustache(token, buffer);
        }
    }
}
exports.Parser = Parser;
