"use strict";
/*
 * @adonisjs/ace
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManifestLoader = void 0;
const fs_extra_1 = require("fs-extra");
const utils_1 = require("@poppinss/utils");
const validateCommand_1 = require("../utils/validateCommand");
/**
 * The manifest loader exposes the API to load ace commands from one
 * or more manifest files.
 */
class ManifestLoader {
    constructor(files) {
        this.files = files;
        this.manifestFiles = [];
        this.booted = false;
    }
    /**
     * Loads the manifest file from the disk
     */
    async loadManifestFile(file) {
        const manifestCommands = await fs_extra_1.readJSON(file.manifestAbsPath);
        return { basePath: file.basePath, commands: manifestCommands };
    }
    /**
     * Boot manifest loader to read all manifest files from the disk
     */
    async boot() {
        if (this.booted) {
            return;
        }
        this.booted = true;
        this.manifestFiles = await Promise.all(this.files.map((file) => this.loadManifestFile(file)));
    }
    /**
     * Returns base path for a given command
     */
    getCommandBasePath(commandName) {
        var _a;
        return (_a = this.manifestFiles.find(({ commands }) => {
            return commands[commandName];
        })) === null || _a === void 0 ? void 0 : _a.basePath;
    }
    /**
     * Returns manifest command node. One must load the command
     * in order to use it
     */
    getCommand(commandName) {
        const manifestCommands = this.manifestFiles.find(({ commands }) => {
            return commands[commandName];
        });
        if (!manifestCommands) {
            return;
        }
        return {
            basePath: manifestCommands.basePath,
            command: manifestCommands.commands[commandName],
        };
    }
    /**
     * Find if a command exists or not
     */
    hasCommand(commandName) {
        return !!this.getCommandBasePath(commandName);
    }
    /**
     * Load command from the disk. Make sure to use [[hasCommand]] before
     * calling this method
     */
    loadCommand(commandName) {
        const { basePath, command } = this.getCommand(commandName);
        const commandConstructor = utils_1.esmRequire(utils_1.resolveFrom(basePath, command.commandPath));
        validateCommand_1.validateCommand(commandConstructor);
        return commandConstructor;
    }
    /**
     * Returns an array of manifest commands
     */
    getCommands() {
        return this.manifestFiles.reduce((result, { commands }) => {
            Object.keys(commands).forEach((commandName) => {
                result = result.concat(commands[commandName]);
            });
            return result;
        }, []);
    }
}
exports.ManifestLoader = ManifestLoader;
